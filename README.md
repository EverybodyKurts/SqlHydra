# SqlHydra
SqlHydra is a suite of NuGet packages for working with databases in F#.

- [SqlHydra.SqlServer](#sqlhydrasqlserver-) is a dotnet tool that generates F# records for a SQL Server database.
- [SqlHydra.Sqlite](#sqlhydrasqlite-) is a dotnet tool that generates F# records for a SQLite database.
- [SqlHydra.Query](#sqlhydraquery-) is an F# query generator computation expression powered by [SqlKata](https://sqlkata.com/) that supports the following databases:
    - SQL Server, SQLite, PostgreSql, MySql, Oracle, Firebird

## Contributing
* This project uses the vs-code Remote-Containers extension to spin up a dev environment that includes databases for running the Tests project.
* To initialize SQL Server after the `mssql` container spins up, open the CLI and run `bash install.sh`.

## SqlHydra.SqlServer [![NuGet version (SqlHydra.SqlServer)](https://img.shields.io/nuget/v/SqlHydra.SqlServer.svg?style=flat-square)](https://www.nuget.org/packages/SqlHydra.SqlServer/)

### Local Install (recommended)
Run the following commands from your project directory:
1) `dotnet new tool-manifest`
2) `dotnet tool install SqlHydra.SqlServer`

### Configure and Run

Run the tool from the command line (or add to a .bat|.cmd|.sh file):

```bat
dotnet sqlhydra-mssql
```

* The configuration wizard will ask you some questions, create a new .toml configuration file for you, and then run your new config.
* If a .toml configuration file already exists, it will run.
* The generated .fs file will automatically be added to your .fsproj as `Visible="false"`.

![hydra-console](https://user-images.githubusercontent.com/1030435/127790303-a69ca6ea-f0a7-4216-aa5d-c292b0dc3229.gif)

### Build Event (optional)

To regenerate on each build, you can run SqlHydra from a .fsproj PreBuild or PostBuild event. 
```bat
  <Target Name="PreBuild" BeforeTargets="PreBuildEvent">
    <Exec Command="dotnet sqlhydra-mssql" />
  </Target>
```

⭐ To regenerate only after a Rebuild:
```bat
  <Target Name="SqlHydra" BeforeTargets="Clean">
    <Exec Command="dotnet sqlhydra-mssql" />
  </Target>
```


## SqlHydra.Sqlite [![NuGet version (SqlHydra.Sqlite)](https://img.shields.io/nuget/v/SqlHydra.SqlServer.svg?style=flat-square)](https://www.nuget.org/packages/SqlHydra.Sqlite/)

### Local Install (recommended)
Run the following commands from your project directory:
1) `dotnet new tool-manifest`
2) `dotnet tool install SqlHydra.Sqlite`

### Configure / Run

Run the tool from the command line (or add to a .bat|.cmd|.sh file):

```bat
dotnet sqlhydra-sqlite
```

* The configuration wizard will ask you some questions, create a new .toml configuration file for you, and then run your new config.
* If a .toml configuration file already exists, it will run.
* The generated .fs file will automatically be added to your .fsproj as `Visible="false"`.

### Build Event (optional)
To regenerate on each build, you can run SqlHydra from a .fsproj PreBuild or PostBuild event. 

```bat
  <Target Name="PreBuild" BeforeTargets="PreBuildEvent">
    <Exec Command="dotnet sqlhydra-sqlite" />
  </Target>
```

⭐ To regenerate only after a Rebuild:
```bat
  <Target Name="SqlHydra" BeforeTargets="Clean">
    <Exec Command="dotnet sqlhydra-sqlite" />
  </Target>
```


### Example Output for AdventureWorks
```F#
// This code was generated by SqlHydra.SqlServer.
namespace SampleApp.AdventureWorks

module dbo =
    type ErrorLog =
        { ErrorLogID: int
          ErrorTime: System.DateTime
          UserName: string
          ErrorNumber: int
          ErrorMessage: string
          ErrorSeverity: Option<int>
          ErrorState: Option<int>
          ErrorProcedure: Option<string>
          ErrorLine: Option<int> }

    type BuildVersion =
        { SystemInformationID: byte
          ``Database Version``: string
          VersionDate: System.DateTime
          ModifiedDate: System.DateTime }

module SalesLT =
    type Address =
        { City: string
          StateProvince: string
          CountryRegion: string
          PostalCode: string
          rowguid: System.Guid
          ModifiedDate: System.DateTime
          AddressID: int
          AddressLine1: string
          AddressLine2: Option<string> }

    type Customer =
        { LastName: string
          PasswordHash: string
          PasswordSalt: string
          rowguid: System.Guid
          ModifiedDate: System.DateTime
          CustomerID: int
          NameStyle: bool
          FirstName: string
          MiddleName: Option<string>
          Title: Option<string>
          Suffix: Option<string>
          CompanyName: Option<string>
          SalesPerson: Option<string>
          EmailAddress: Option<string>
          Phone: Option<string> }
    
    // etc...
```


### Data Readers
The generated `HydraReader` class works in tandem with SqlHydra.Query for reading queried entities, but they can also be used on their own with any query provider that returns an IDataReader.

* [Using HydraReader automatically with SqlHydra.Query](#sqlhydraquery-)
* [Using HydraReader manually with other query libraries](https://github.com/JordanMarr/SqlHydra/wiki/DataReaders)

### TOML Configuration Reference
* [View TOML Configuration Reference](https://github.com/JordanMarr/SqlHydra/wiki/TOML-Configuration)

## SqlHydra.Query [![NuGet version (SqlHydra.Query)](https://img.shields.io/nuget/v/SqlHydra.Query.svg?style=flat-square)](https://www.nuget.org/packages/SqlHydra.Query/)
SqlHydra.Query wraps the powerful [SqlKata](https://sqlkata.com/) query generator with F# computation expression builders for strongly typed query generation.
It can create queries for the following databases: SQL Server, SQLite, PostgreSql, MySql, Oracle, Firebird.
SqlHydra.Query can be used with any library that accepts a data reader; however, is designed pair well with SqlHydra generated records and readers! 

### Setup

```F#
open SqlHydra.Query

// Tables
let customerTable =         table<SalesLT.Customer>         |> inSchema (nameof SalesLT)
let customerAddressTable =  table<SalesLT.CustomerAddress>  |> inSchema (nameof SalesLT)
let addressTable =          table<SalesLT.Address>          |> inSchema (nameof SalesLT)
let productTable =          table<SalesLT.Product>          |> inSchema (nameof SalesLT)
let categoryTable =         table<SalesLT.ProductCategory>  |> inSchema (nameof SalesLT)
let errorLogTable =         table<dbo.ErrorLog>
```

```F#
/// Opens a connection and creates a QueryContext that will generate SQL Server dialect queries
let openContext() = 
    let compiler = SqlKata.Compilers.SqlServerCompiler()
    let conn = openConnection()
    new QueryContext(conn, compiler)
```

### Select Builder

The following select queries will use the `HydraReader.Read` method generated by `SqlHydra.*` when the [Readers](#data-readers) option is selected.
`HydraReader.Read` infers the type generated by the query and uses the generated reader to hydrate the queried entities.

Selecting city and state columns only:
```F#
use ctx = openContext()

let cities =
    select {
        for a in addressTable do
        where (a.City = "Seattle")
        select (a.City, a.StateProvince)
    }
    |> ctx.Read HydraReader.Read
    |> List.map (fun (city, state) -> $"City, State: %s{city}, %s{state}")
```

_Special `where` filter operators:_
- `isIn` or `|=|`
- `isNotIn` or `|<>|`
- `like` or `=%`
- `notLike` or `<>%`
- `isNullValue` or `= None`
- `isNotNullValue` or `<> None`
- `subqueryMany`
- `subqueryOne`


Select `Address` entities where City starts with `S`:
```F#
let addresses =
    select {
        for a in addressTable do
        where (a.City =% "S%")
    }
    |> ctx.Read HydraReader.Read
```

#### Joins

Select top 10 `Product` entities with inner joined category name:
```F#
let! productsWithCategory = 
    select {
        for p in productTable do
        join c in categoryTable on (p.ProductCategoryID.Value = c.ProductCategoryID)
        select (p, c.Name)
        take 10
    }
    |> ctx.ReadAsync HydraReader.Read
```

Select `Customer` with left joined `Address` where `CustomerID` is in a list of values:
(Note that left joined tables will be of type `'T option`, so you will need to use the `.Value` property to access join columns.)

```F#
let! customerAddresses =
    select {
        for c in customerTable do
        leftJoin ca in customerAddressTable on (c.CustomerID = ca.Value.CustomerID)
        leftJoin a  in addressTable on (ca.Value.AddressID = a.Value.AddressID)
        where (c.CustomerID |=| [1;2;30018;29545]) // two without address, two with address
        orderBy c.CustomerID
        select (c, a)
    }
    |> ctx.ReadAsync HydraReader.Read
```

#### Aggregates

_Aggregate functions (can be used in `select`, `having` and `orderBy` clauses):_
- `countBy`
- `sumBy`
- `minBy`
- `maxBy`
- `avgBy`

```F#
// Select categories with an avg product price > 500 and < 1000
select {
    for p in productTable do
    where (p.ProductCategoryID <> None)
    groupBy p.ProductCategoryID
    having (minBy p.ListPrice > 500M && maxBy p.ListPrice < 1000M)
    select (p.ProductCategoryID, minBy p.ListPrice, maxBy p.ListPrice)
}
|> ctx.Read HydraReader.Read
|> Seq.map (fun (catId, minPrice, maxPrice) -> $"CatID: {catId}, MinPrice: {minPrice}, MaxPrice: {maxPrice}")
|> Seq.iter (printfn "%s")
```

Alternative Row Count Query:
```F#
let! customersWithNoSalesPersonCount =
    select {
        for c in customerTable do
        where (c.SalesPerson = None)
        count
    }
    |> ctx.CountAsync
```

#### WHERE Subqueries

_Use the `subqueryMany` function for subqueries that return multiple rows for comparison:_

```F#
// Create a subquery that gets top 5 avg prices by category ID:
let top5CategoryIdsWithHighestAvgPrices = 
    select {
        for p in productTable do
        where (p.ProductCategoryID <> None)
        groupBy p.ProductCategoryID
        orderByDescending (avgBy p.ListPrice)
        select p.ProductCategoryID
        take 5
    }

// Get category names where the category ID is "IN" the subquery:
let top5Categories =
    select {
        for c in categoryTable do
        where (Some c.ProductCategoryID |=| subqueryMany top5CategoryIdsWithHighestAvgPrices)
        select c.Name
    }
    |> ctx.ReadAsync HydraReader.Read
```

_Use the `subqueryOne` function for subqueries that return a single value for comparison:_

```F#
// Create a subquery that gets the avg list price (a single value):
let avgListPrice = 
    select {
        for p in productTable do
        select (avgBy p.ListPrice)
    } 

// Get products with a price > the average price
let productsWithAboveAveragePrice =
    select {
        for p in productTable do
        where (p.ListPrice > subqueryOne avgListPrice)
        select (p.Name, p.ListPrice)
    }
    |> ctx.ReadAsync HydraReader.Read
```

Distinct Query:
```F#
let! distinctCustomerNames = 
    select {
        for c in customerTable do
        select (c.FirstName, c.LastName)
        distinct
    }
    |> ctx.ReadAsync HydraReader.Read
```

### Dos and Don'ts

:boom: The `select` clause currently only supports tables and fields for the sake of modifying the generated SQL query and the returned query type `'T`.
Transformations (i.e. `.ToString()` or calling any functions is _not supported_ and will throw an exception.

:boom: The `where` clause will automatically parameterize your input values. _However_, similar to the `select` clause, the `where` clause does not support calling an transformations (i.e. `.ToString()`). So you must prepare any parameter transformations before the builder. 

✔️ CORRECT:
```F#
let city = getCity() // DO prepare where parameters above and then pass into the where clause

let cities =
    select {
        for a in addressTable do
        where (a.City = city)
        select (a.City, a.StateProvince)
    }
    |> ctx.Read HydraReader.Read
    |> List.map (fun (city, state) -> $"City: %s{city}, State: %s{state}") // DO transforms after data is queried
```

❌ INCORRECT:
```F#
let cities =
    select {
        for a in addressTable do
        where (a.City = getCity()) // DO NOT perform calculations or translations within the builder
        select ("City: " + a.City, "State: " + a.StateProvince) // DO NOT perform translations within the builder 
    }
    |> ctx.Read HydraReader.Read
    |> List.map (fun (city, state) -> $"%s{city}, %s{state}")
```

### Insert Builder

For simple inserts with no identity column and no included/excluded columns, use the `into _` syntax:

```F#
let person = 
    {
        dbo.Person.ID = Guid.NewGuid()
        dbo.Person.FirstName = "Bojack"
        dbo.Person.LastName = "Horseman"
        dbo.Person.LastUpdated = DateTime.Now
    }

let result = 
    insert {
        into personTable
        entity person
    }
    |> ctx.Insert

printfn "Result: %i" result
```

If you have an Identity column or if you want to specify columns to include/exclude, use the `for _ in _ do` syntax.

```F#

let errorLog = 
    {
        dbo.ErrorLog.ErrorLogID = 0 // Identity column
        dbo.ErrorLog.ErrorTime = System.DateTime.Now
        dbo.ErrorLog.ErrorLine = None
        dbo.ErrorLog.ErrorMessage = "TEST"
        dbo.ErrorLog.ErrorNumber = 400
        dbo.ErrorLog.ErrorProcedure = (Some "Procedure 400")
        dbo.ErrorLog.ErrorSeverity = None
        dbo.ErrorLog.ErrorState = None
        dbo.ErrorLog.UserName = "jmarr"
    }

let errorID : int = // Specify 'Identity output is of type int
    insert {
        for e in errorLogTable do
        entity errorLog
        excludeColumn e.ErrorLogID // Exclude the identity field
    }
    |> ctx.InsertGetId

printfn "ErrorID Identity: %i" errorID
```

### Update Builder

Update individual fields:
```F#
let result = 
    update {
        for e in errorLogTable do
        set e.ErrorNumber 123
        set e.ErrorMessage "ERROR #123"
        set e.ErrorLine (Some 999)
        set e.ErrorProcedure None
        where (e.ErrorLogID = 1)
    }
    |> ctx.Update
```

Update an entity with fields excluded/included:
```F#
let result = 
    update {
        for e in errorLogTable do
        entity errorLog
        excludeColumn e.ErrorLogID
        where (e.ErrorLogID = errorLog.ErrorLogID)
    }
    |> ctx.Update

```

### Delete Builder

```F#
let result = 
    delete {
        for e in errorLogTable do
        where (e.ErrorLogID = 5)
    }
    |> ctx.Delete

printfn "result: %i" result
```
