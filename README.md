# SqlHydra
SqlHydra is a [Myriad](https://github.com/MoiraeSoftware/myriad) plugin that generates F# records from a SQL Server SSDT .dacpac file.

[![NuGet version (SqlHydra)](https://img.shields.io/nuget/v/SqlHydra.svg?style=flat-square)](https://www.nuget.org/packages/SqlHydra/)

## Setup

1) Install `SqlHydra` and `Myriad.Sdk` from NuGet.

2) Add a `myriad.toml` configuration file to your project with a namespace that will contain your generated F# record types:

```toml
[ssdt]
namespace = "AdventureWorks"
```


3) Add an `ItemGroup` to your .fsproj file to configure a .dacpac input file and an .fs output file:

```xml
    <ItemGroup>
         <!-- Specify the .fs output file (to be generated by Myriad) -->
        <Compile Include="AdventureWorks.fs">
            <!-- Specify the .dacpac input  file -->
            <MyriadFile>../AdventureWorks/bin/Debug/AdventureWorks.dacpac</MyriadFile>
        </Compile>
    </ItemGroup>

```

4) Build your project to generate the .fs file.

5) Use your generated types with a micro ORM like FSharp.Dapper or RepoDb.

## Benefits of Myriad
* Myriad + SSDT is fast - very low impact on your build
* Myriad detects changes to SSDT .dacpac file and regenerates on next build
* Generated types are records, not classes (algebraic type safety for your data layer)
* Generated types can be used outside of project
* Generated types can be checked into source control (build server friendly)

## Officially Recommended ORM: Dapper.FSharp!

After creating SqlHydra, I was trying to find the perfect ORM to complement SqlHyda's generated records.
Ideally, I wanted to find a library with 
- Excellent F# support for records, Option types, etc.
- Linq queries (to take advantage of strongly typed SqlHydra generated records)

[FSharp.Dapper](https://github.com/Dzoukr/Dapper.FSharp) met the first critera with flying colors. 
As the name suggests, Dapper.FSharp was written specifically for F# with simplicity and ease-of-use as the driving design priorities.
FSharp.Dapper features custom F# Computation Expressions for selecting, inserting, updating and deleting, and support for F# Option types and records (no need for `[<CLIMutable>]` attributes!).

If only it had Linq queries, it would be the _perfect_ complement to SqlHydra...

_So_ I submitted a [PR](https://github.com/Dzoukr/Dapper.FSharp/pull/26) to Dapper.FSharp that adds Linq query expressions (now in v2.0+)!

This is the result:

```fsharp
module DapperFSharpExample
open System.Data
open System.Data.SqlClient
open Dapper.FSharp.LinqBuilders
open Dapper.FSharp.MSSQL
open AdventureWorks // Generated Types

Dapper.FSharp.OptionTypes.register()
    
// Tables
let customerTable =         table<Customer>         |> inSchema (nameof SalesLT)
let customerAddressTable =  table<CustomerAddress>  |> inSchema (nameof SalesLT)
let addressTable =          table<SalesLT.Address>  |> inSchema (nameof SalesLT)

let getAddressesForCity(conn: IDbConnection) (city: string) = 
    select {
        for a in addressTable do
        where (a.City = city)
    } |> conn.SelectAsync<SalesLT.Address>
    
let getCustomersWithAddresses(conn: IDbConnection) =
    select {
        for c in customerTable do
        leftJoin ca in customerAddressTable on (c.CustomerID = ca.CustomerID)
        leftJoin a  in addressTable on (ca.AddressID = a.AddressID)
        where (isIn c.CustomerID [30018;29545;29954;29897;29503;29559])
        orderBy c.CustomerID
    } |> conn.SelectAsyncOption<Customer, CustomerAddress, Address>

```


## SSDT Type Annotations
There are a few known issues with the SSDT generated types:
* User defined data types are not supported
* Computed table and view columns will default to a data type of `obj` since the data type is not listed in the .dacpac file.

As a work-around for the above issues, the .dacpac parser allows you to add type annotations directly to the table or view .sql files as in-line comments.

In the SalesOrderDetail.sql example table below, `[LineTotal]` is a computed column. Since the .dacpac file cannot determine the datatype for computed columns, the data type of the generated property will be defaulted to `obj`. As a workaround, an in-line type annotation `/* MONEY NOT NULL */` can be added. NOTE: for computed table columns, the comment annotation must be contained within the parentheses.

```sql
CREATE TABLE [SalesLT].[SalesOrderDetail] (
[SalesOrderID]       INT              NOT NULL,
[SalesOrderDetailID] INT              IDENTITY (1, 1) NOT NULL,
[OrderQty]           SMALLINT         NOT NULL,
[ProductID]          INT              NOT NULL,
[UnitPrice]          MONEY            NOT NULL,
[UnitPriceDiscount]  MONEY            CONSTRAINT [DF_SalesOrderDetail_UnitPriceDiscount] DEFAULT ((0.0)) NOT NULL,
[LineTotal]          AS               (isnull(([UnitPrice]*((1.0)-[UnitPriceDiscount]))*[OrderQty],(0.0)) /* MONEY NOT NULL */ ),
[rowguid]            UNIQUEIDENTIFIER CONSTRAINT [DF_SalesOrderDetail_rowguid] DEFAULT (newid()) ROWGUIDCOL NOT NULL,
[ModifiedDate]       DATETIME         CONSTRAINT [DF_SalesOrderDetail_ModifiedDate] DEFAULT (getdate()) NOT NULL,
...
```

In the example `dbo.v_Hours` view below, the `Hours` column is not linked back to the `dbo.TimeEntries.Hours` column in the .dacpac metadata because it is a calculated field, so the data type of the generated property will be defaulted to `obj`. Adding a type annotation within an in-line comment will inform the SSDT provider of the data type to use in the generated `Hours` property:

```sql
CREATE VIEW dbo.v_Hours
AS
SELECT dbo.Projects.Name AS ProjectName, COALESCE (dbo.TimeEntries.Hours, 0) AS Hours /* decimal not null */, dbo.Users.Username
FROM dbo.Projects
INNER JOIN dbo.TimeEntries on dbo.Projects.Id = dbo.TimeEntries.ProjectId
INNER JOIN dbo.Users on dboUsers.Id = dbo.TimeEntries.UserId
```

_Notes:_
* If no null constraint is added after the column type, it will allow nulls by default.
* The annotations are case-insensitive.
* Hovering over a generated view property will designate if the data type was derived from a type annotations (or if it needs one).
* Do not include length information in the type annotation. For example, use varchar, not varchar(20).

## Roadmap
* Adding new Myriad generators that directly pull schema from SQL Server and other database providers
* Add a configuration option to add `[<CLIMutable>]` attribute to generated records (required by some ORMs like vanilla Dapper and EF).
* Adding generated helpers as needed to assist with common data flows

