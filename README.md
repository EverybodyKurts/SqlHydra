# SqlHydra
SqlHydra is a [Myriad](https://github.com/MoiraeSoftware/myriad) plugin that generates F# records from a SQL Server SSDT .dacpac file.

[![NuGet version (SqlHydra)](https://img.shields.io/nuget/v/SqlHydra.svg?style=flat-square)](https://www.nuget.org/packages/SqlHydra/)

## Setup

1) Install `SqlHydra` and `Myriad.Sdk` from NuGet.

2) Add a `myriad.toml` configuration file to your project with a namespace that will contain your generated F# record types:

```toml
[ssdt]
namespace = "AdventureWorks"
```


3) Add an `ItemGroup` to your .fsproj file to configure a .dacpac input file and an .fs output file:

```xml
    <ItemGroup>
         <!-- Specify the .fs output file (to be generated by Myriad) -->
        <Compile Include="AdventureWorks.fs">
            <!-- Specify the .dacpac input  file -->
            <MyriadFile>../AdventureWorks/bin/Debug/AdventureWorks.dacpac</MyriadFile>
        </Compile>
    </ItemGroup>

```

4) Build your project to generate the .fs file.

5) Use your generated types with a micro ORM like FSharp.Dapper or RepoDb.

## Benefits of Myriad
* Myriad + SSDT is fast - very low impact on your build
* Myriad detects changes to SSDT .dacpac file and regenerates on next build
* Generated types are records, not classes (algebraic type safety for your data layer)
* Generated types can be used outside of project
* Generated types can be checked into source control (build server friendly)

## Use Case - RepoDb
[RepoDb](https://repodb.net/) is a micro ORM that gives very high performance with strongly typed Linq style queries.
In conjunction with SqlHydra-Myriad, you get the best of performance and type safety.
Even better, RepoDb provides [first-class support](https://www.compositional-it.com/news-blog/repodb-on-f/) for F# features like Option types and records (no need for `[<CLIMutable>]` attributes) out-of-the-box!

```fsharp
module RepoDbExample
open Microsoft.Data.SqlClient
open RepoDb
open AdventureWorks // Generated Types

SqlServerBootstrap.Initialize()

FluentMapper
    .Entity<SalesLT.Address>().Table("[SalesLT].[Address]") // Must manually register non- "dbo" schemas
    |> ignore

let connect() = 
    let conn = new SqlConnection("Data Source=localhost\SQLEXPRESS;Initial Catalog=AdventureWorksLT2019;Integrated Security=SSPI;")
    conn.Open()
    conn

let runQueries() =    
    use conn = connect()

    conn.Query(fun (a: SalesLT.Address) -> a.City = "Dallas")
    |> printfn "Addresses: %A"

    conn.QueryAll<dbo.BuildVersion>()
    |> printfn "Build Versions: %A"
```

## Use Case - FSharp.Dapper
As the name implies, [FSharp.Dapper](https://github.com/Dzoukr/Dapper.FSharp) was written for F# with simplicity and ease-of-use as the driving design priorities.
FSharp.Dapper features custom F# Computation Expressions for selecting, inserting, updating and deleting, and support for F# Option types and records (no need for `[<CLIMutable>]` attributes).

```fsharp
module DapperFSharpExample
open System.Data
open System.Data.SqlClient
open Dapper.FSharp
open Dapper.FSharp.MSSQL
open AdventureWorks // Generated Types

Dapper.FSharp.OptionTypes.register()

let connect() = 
    let cs = "Data Source=localhost\SQLEXPRESS;Initial Catalog=AdventureWorksLT2019;Integrated Security=SSPI;"
    let conn = new SqlConnection(cs) :> IDbConnection
    conn.Open()
    conn

let getAddressesForCity(conn: IDbConnection) (city: string) = 
    select {
        table "SalesLT.Address"
        where (eq "City" city)
    } 
    |> conn.SelectAsync<SalesLT.Address>
    |> Async.AwaitTask 

let runQueries() = 
    
    use conn = connect()
    
    let addresses = getAddressesForCity conn "Dallas" |> Async.RunSynchronously

    printfn "Dallas Addresses: %A" addresses
```


## SSDT Type Annotations
There are a few known issues with the SSDT generated types:
* User defined data types are not supported
* Computed table and view columns will default to a data type of `obj` since the data type is not listed in the .dacpac file.

As a work-around for the above issues, the .dacpac parser allows you to add type annotations directly to the table or view .sql files as in-line comments.

In the SalesOrderDetail.sql example table below, `[LineTotal]` is a computed column. Since the .dacpac file cannot determine the datatype for computed columns, the data type of the generated property will be defaulted to `obj`. As a workaround, an in-line type annotation `/* MONEY NOT NULL */` can be added. NOTE: for computed table columns, the comment annotation must be contained within the parentheses.

```sql
CREATE TABLE [SalesLT].[SalesOrderDetail] (
[SalesOrderID]       INT              NOT NULL,
[SalesOrderDetailID] INT              IDENTITY (1, 1) NOT NULL,
[OrderQty]           SMALLINT         NOT NULL,
[ProductID]          INT              NOT NULL,
[UnitPrice]          MONEY            NOT NULL,
[UnitPriceDiscount]  MONEY            CONSTRAINT [DF_SalesOrderDetail_UnitPriceDiscount] DEFAULT ((0.0)) NOT NULL,
[LineTotal]          AS               (isnull(([UnitPrice]*((1.0)-[UnitPriceDiscount]))*[OrderQty],(0.0)) /* MONEY NOT NULL */ ),
[rowguid]            UNIQUEIDENTIFIER CONSTRAINT [DF_SalesOrderDetail_rowguid] DEFAULT (newid()) ROWGUIDCOL NOT NULL,
[ModifiedDate]       DATETIME         CONSTRAINT [DF_SalesOrderDetail_ModifiedDate] DEFAULT (getdate()) NOT NULL,
...
```

In the example `dbo.v_Hours` view below, the `Hours` column is not linked back to the `dbo.TimeEntries.Hours` column in the .dacpac metadata because it is a calculated field, so the data type of the generated property will be defaulted to `obj`. Adding a type annotation within an in-line comment will inform the SSDT provider of the data type to use in the generated `Hours` property:

```sql
CREATE VIEW dbo.v_Hours
AS
SELECT dbo.Projects.Name AS ProjectName, COALESCE (dbo.TimeEntries.Hours, 0) AS Hours /* decimal not null */, dbo.Users.Username
FROM dbo.Projects
INNER JOIN dbo.TimeEntries on dbo.Projects.Id = dbo.TimeEntries.ProjectId
INNER JOIN dbo.Users on dboUsers.Id = dbo.TimeEntries.UserId
```

_Notes:_
* If no null constraint is added after the column type, it will allow nulls by default.
* The annotations are case-insensitive.
* Hovering over a generated view property will designate if the data type was derived from a type annotations (or if it needs one).
* Do not include length information in the type annotation. For example, use varchar, not varchar(20).

## Roadmap
* Adding new Myriad generators that directly pull schema from SQL Server and other database providers
* Add a configuration option to add `[<CLIMutable>]` attribute to generated records (required by some ORMs like vanilla Dapper and EF).
* Adding generated helpers as needed to assist with common data flows

